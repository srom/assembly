"""
Some assemblies on NCBI do not include protein annotations (e.g. a GFF file).
This script predicts CDS with [Prodigal](https://github.com/hyattpd/prodigal/).
"""
import argparse
import logging
import os
import subprocess
import sys
from multiprocessing import Process
from pathlib import Path
from typing import List

import numpy as np
import pandas as pd

from src.utils import get_accession_from_path_name, get_n_cpus


logger = logging.getLogger()


def main():
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(processName)-10s (%(levelname)s) %(message)s')

    parser = argparse.ArgumentParser(
        description='Predict CDS with Prodigal',
    )
    parser.add_argument(
        '-i', '--assemblies', 
        help='Path to base folder containing genome assemblies, as generated by the script fetch_assemblies', 
        type=str,
    )
    parser.add_argument('--cpu', type=int, default=4)
    args = parser.parse_args()

    base_folder = Path(args.assemblies)
    n_cpus = min(args.cpu, get_n_cpus())

    if not base_folder.is_dir():
        logger.error(f'Assemblies folder does not exist: {args.assemblies}')
        sys.exit(1)

    genomes_folder = base_folder / 'genomes'
    if not genomes_folder.is_dir():
        logger.error(f'Genomes folder does not exist: {genomes_folder}')
        sys.exit(1)

    metadata_path = base_folder / 'genomes_metadata.csv'
    if not metadata_path.is_file():
        logger.error(f'Genomes metadata file does not exist: {metadata_path}')
        sys.exit(1)

    metadata_df = pd.read_csv(metadata_path, index_col='assembly_accession')
    assembly_accession_index = metadata_df.index

    logger.info(f'Predicting missing annotation for assemblies in {genomes_folder}')
    paths = [
        p for p in base_folder.iterdir()
        if (
            p.is_dir() and 
            p.name.startswith('GC') and 
            get_accession_from_path_name(p) in assembly_accession_index
        )
    ]
    logger.info(f'Total number of assemblies: {len(paths):,}')

    paths_to_process = []
    for path in paths:
        name = path.name
        if not (path / f'{name}_protein.faa.gz').is_file():
            paths_to_process.append(path)

    logger.info(f'Assemblies without annotations: {len(paths_to_process):,}')

    if len(paths_to_process) == 0:
        logger.info('No predictions needed.')
        sys.exit(0)

    n_cpus = min(n_cpus, len(paths_to_process))
    n_per_process = int(np.ceil(len(paths_to_process) / n_cpus))

    processes = []
    for i in range(n_cpus):
        start = i * n_per_process
        end = start + n_per_process
 
        p = Process(target=worker_main, args=(
            i,
            paths_to_process[start:end],
        ))
        p.start()
        processes.append(p)

    for p in processes:
        p.join()

    logger.info('DONE')
    sys.exit(0)


def worker_main(worker_ix : int, paths_to_process : List[os.PathLike]):
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(processName)-10s (%(levelname)s) %(message)s')

    for i, path in enumerate(paths_to_process):
        if i == 0 or (i+1) % 100 == 0 or (i+1) == len(paths_to_process):
            logger.info(f'Worker {worker_ix+1} | Processing assembly {i+1:,} / {len(paths_to_process)}')

        genome_path_gz = path / f'{path.name}_genomic.fna.gz'
        if not genome_path_gz.is_file():
            logger.error(f'No genome fasta file found for {path.name}')
            continue

        # Decompress input genome
        genome_path = path / f'{path.name}_genomic.fna'
        response = subprocess.run(['gzip', '-dk', genome_path_gz.resolve().as_posix()], capture_output=True)

        if response.returncode != 0:
            stderr_txt = response.stderr.decode('utf-8')
            logger.error(f'Error while decompressing {genome_path_gz}: {stderr_txt}')
            continue

        try:
            gff_output_path = path / f'{path.name}_genomic.gff'
            protein_path = path / f'{path.name}_protein.faa'
            cds_path = path / f'{path.name}_cds_from_genomic.fna'

            # Run Prodigal
            response = subprocess.run(
                [
                    'prodigal',
                    '-i', genome_path.resolve().as_posix(),   # input genome
                    '-o', gff_output_path,                    # annotation file
                    '-f', 'gff',                              # output format
                    '-a', protein_path.resolve().as_posix(),  # protein file 
                    '-d', cds_path.resolve().as_posix(),      # CDS file
                    '-q',                                     # quiet
                ], 
                capture_output=True,
            )
            if response.returncode != 0:
                stderr_txt = response.stderr.decode('utf-8')
                logger.error(f'Error while running Prodigal on {genome_path}: {stderr_txt}')
                continue

            # Compress outputs
            for f in [gff_output_path, protein_path, cds_path]:
                response = subprocess.run(['gzip', f.resolve().as_posix()], capture_output=True)

                if response.returncode != 0:
                    stderr_txt = response.stderr.decode('utf-8')
                    logger.error(f'Error while compressing {f}: {stderr_txt}')

        finally:
            if genome_path.is_file():
                genome_path.unlink()  # remove uncompressed genome


if __name__ == '__main__':
    main()
